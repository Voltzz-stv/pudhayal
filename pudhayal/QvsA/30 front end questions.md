https://youtu.be/zM2nzL2Jngo?si=St1EA48cW40JPdm1
### Front-End Fundamentals & Performance (Questions 1-13)

| Question                                                                                                                                                 | Answer                                                                                                                                                                                                                                                                                                                                                             |
| :------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Question 1:** Is CSS rendered before or after the DOM is constructed in the critical rendering path?                                                   | **CSS is rendered before** the DOM is constructed. It is synchronous, meaning it all has to be interpreted before the browser starts parsing and showing the DOM.                                                                                                                                                                                                  |
| **Question 2:** HTML is rendered incrementally as it is being interpreted. Can we say the same about CSS?                                                | **No**, CSS is blocking, meaning it is "all or nothing". This is because CSS is a **global namespace**, requiring the browser to interpret all CSS and calculate every possible rule before moving forward with the HTML.                                                                                                                                          |
| **Question 3:** Which one will be interpreted after the HTML is fully rendered, `async` or `defer` or the first script that will be interpreted first?   | **`defer`** will actually be done after the DOM finish event. `async` will be interpreted as soon as it is downloaded, even though both scripts start downloading in the background.                                                                                                                                                                               |
| **Question 4:** Given that the `box-sizing` property of an element is `border-box`, is the padding included in the width calculation?                    | **Yes**, the padding is included in the width calculation when `box-sizing` is set to `border-box`.                                                                                                                                                                                                                                                                |
| **Question 5:** Tell me three ways I can optimize my CSS to make my web application faster.                                                              | 1. **Clean it up** using the coverage tool from the browser to ship only used styles. 2. **Compression and caching**. 3. **Critical CSS**, which involves extracting the CSS needed for the first render and loading the rest after the initial render.                                                                                                            |
| **Question 6:** What will be the final color of the button (Context: specific code snippet using CSS specificity)?                                       | The final color will probably be **green**. This is because an ID has the highest specificity, which is assumed to be the selector applied.                                                                                                                                                                                                                        |
| **Question 7:** What are the different ways to store data in the browser?                                                                                | We can use **cookies**, **local storage**, and **session storage**.                                                                                                                                                                                                                                                                                                |
| **Question 8:** What is one advantage and one disadvantage of using closures in JavaScript?                                                              | **Advantage:** Having **simpler function signatures** because you do not need to pass many things into a function, as the function has access to the local and global scope. **Disadvantage:** Using a **lot of memory** because enclosed functions keep many variables that cannot be garbage collected, as JavaScript is traditionally poor for memory handling. |
| **Question 9:** A user presses the submit button too often triggering too many calls to our backend. How can we fix it?                                  | We could use **debounce or throttle**. For a button submission, throttling could also work, though if it were an input field where the user was typing, debouncing would be suggested.                                                                                                                                                                             |
| **Question 10:** What is the order of execution (Context: code snippet involving promises and `setTimeout`)?                                             | The synchronous code executes first (`script end`). Then, the callback from the promise resolution goes to the microtask queue and executes. The event tick finishes. In the next tick, the timeout prints.                                                                                                                                                        |
| **Question 11:** What is the time complexity of the following code (Context: code snippet using `array.sort` and `reduce`)?                              | The time complexity is **N logarithm of N (N log N)**. This is due to `array.sort` in JavaScript implementing an N log N sorting function, which is the dominant term over the N complexity of `reduce`.                                                                                                                                                           |
| **Question 12:** Why is `Person` also an `Employee` in the following TypeScript code (Context: initiating a person and declaring them as type employee)? | This works because TypeScript uses **structural typing**. In TypeScript, if two types have the same properties, they are considered the same.                                                                                                                                                                                                                      |
| **Question 13:** What do ES6 modules allow you to do that `require` does not?                                                                            | ES6 modules provide **static analysis**. This allows the transpiler or module bundler to know more about your modules and perform actions like **tree shaking**. With `require`, information about the modules is not known until `require` is executed at run time.                                                                                               |

### JavaScript & React Concepts (Questions 14-25)

|Question|Answer|
|:--|:--|
|**Question 14:** Explain the `this` keyword in JavaScript.|`this` generally refers to the **global scope** (e.g., the `window` object in a browser). If in an event handler, it refers to the element that triggered the event. If it's a method on an object or class instance, it refers to that object. If `bind` or `apply` is used, it points to what was bound. **Arrow functions** do not have their own `this` and inherit the surrounding scope.|
|**Question 15:** Describe all the steps in an Event Loop tick.|1. **Clean everything in the stack** (run synchronous code until done). 2. **Check the microtask queue** (execute items like promise callbacks). 3. **Repaint the browser** to show updates to the user. The next tick begins after looking at the microtask queue again.|
|**Question 16:** What are the two rules of hooks in React?|1. Hooks should be **at the top of the component**. 2. You should only use hooks **inside another hook or inside a real component**.|
|**Question 17:** Tell me one thing you can do with class components that you cannot do with functional components.|Class components allow you to **hook into different component life cycle methods**. This is necessary for things like controlling re-renders using `shouldComponentUpdate` or implementing **error boundaries**.|
|**Question 18:** Why can't we use async functions as inputs to the `useEffect` hook?|`useEffect` expects the function it receives to return a **cleanup function** when the component unmounts. An `async` function returns a **promise**, which the `useEffect` API does not recognize as a cleanup function.|
|**Question 19:** What does Concurrent React or Synchronous React mean?|Concurrent React (stable with React 18) is the **new architecture style of React**. It uses an internal **priority queue** and can **pause and restart re-render processes**. This allows low-priority renders (like data fetching) to be interrupted for high-priority updates (like user typing or scrolling), making the interface more responsive.|
|**Question 20:** What is a Fiber in React?|A Fiber is the term React uses for a **unit of work** in the new Concurrent architecture. It contains the component's code, props, state, and current memory state. React creates a tree of these Fibers, and this structure allows React to pause and resume re-renders.|
|**Question 21:** Name all the different ways we can optimize the re-rendering process in React.|1. **Avoiding re-renders** by using `useMemo` if the incoming props are the same. 2. If re-rendering cannot be avoided, use **`useMemo` and `useCallback`** to prevent expensive operations inside the component from being recomputed unless dependencies change.|
|**Question 22:** What is rehydration in React specific in the SSR world?|**Rehydration** is the process where, after the server delivers pre-rendered HTML, the client-side React code calls the `hydrateRoot` method to generate the virtual DOM, component tree, and attach all the event handlers to the existing HTML, making it interactive.|
|**Question 23:** What are three ways sibling components can share State?|1. **Lift the state** to a common ancestor/parent. 2. Put the state in a **Context** and connect both siblings to that context. 3. Use a **State Library** (like Redux or Flux).|
|**Question 24:** Name three disadvantages of global state.|1. Abusing it triggers **too many re-renders** across many subscribing components. 2. It introduces **coupling/dependency**, making components harder to move. 3. **Testing is harder** because components cannot be tested in isolation; the global state value must be mocked.|
|**Question 25:** Can you tell me a disadvantage of using React Context?|Using Context excessively can trigger **different re-renders** across connected components. It also reduces maintainability because many components become suddenly connected and require context providers.|

### Optimization, Architecture, & Core Vitals (Questions 26-30)

| Question                                                                                             | Answer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :--------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Question 26:** Name five techniques I can use to make a frontend application faster.               | 1. **Adding a CDN** to serve assets closer to the user. 2. **Compression** (Gzip or Brotli at the HTTP level). 3. **Caching**. 4. **Bundle splitting** (or lazy loading) to defer parts of JavaScript. 5. **Image optimization**, including using better formats like **WebP**.                                                                                                                                                                                                                                                           |
| **Question 27:** What is code splitting and how does it work?                                        | **Code splitting** is loading only parts of a large bundle on demand (lazy loading). It works in modern JavaScript using tools like Webpack, which relies on a dependency tree and, for example, a router to determine which chunks of code are needed for specific routes.                                                                                                                                                                                                                                                               |
| **Question 28:** Which Web Core Vital would be most affected by slow renders?                        | The **Interaction to Next Paint (INP)** is probably the most affected. This metric measures the time from a user interaction to the moment the UI is painted again.                                                                                                                                                                                                                                                                                                                                                                       |
| **Question 29:** Name three advantages and three disadvantages of using SSR (Server Side Rendering). | **Advantages:** 1. **Better SEO**, as pre-rendered HTML is delivered for search bots to interpret. 2. **Better performance** (specifically FCP - First Contentful Paint) because something is shown to the user immediately. 3. (The speaker implies SEO and performance are the main advantages). **Disadvantages:** 1. Increased **complexity** and setup effort. 2. **Coupling** between the front end and the back end. 3. **Framework lock-in** (e.g., locking into Next.js), which requires adapting to framework-specific updates. |
| **Question 30:** What are the top three challenges when building a micro frontend architecture?      | 1. **Maintaining visual consistency** because different micro frontends must share common CSS styles. 2. **Complexity**, as sophisticated work is required to assemble the different pieces in the shell without errors. 3. **Shared state**, such as the shell needing to inject user settings or authentication state into all the independent micro frontends.                                                                                                                                                                         |